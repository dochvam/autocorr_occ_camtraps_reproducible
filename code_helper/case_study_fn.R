#########################################################################
#' Author: Benjamin R. Goldstein
#' case_study_fn.R
#' 
#' This file holds helper functions to support the case study pipeline.
#########################################################################


#' @name fit_om
#' @param umf The unmarkedFrameOccu object used to fit the model
#' @description This function is a wrapper around the unmarked function
#'  `occu` to specify the covariate model used for the case study
fit_om <- function(umf) {

  fit <-   occu(~ Canopy_height_scaled + log_roaddist_scaled
                ~ Temp_max_scaled + Forest_scaled, 
                data = umf, 
                method = "CG", control = list(maxit = 1500))
  
  fit
}

#' @name get_unmarked_summary
#' @param this_fit A fitted unmarked model, as returned by occu
#' @description This function makes a data frame summarizing the results
#'    of a call to occu.
get_unmarked_summary <- function(this_fit) {
  
  cap <- capture.output(state_summary <- summary(this_fit)$state)
  cap <- capture.output(det_summary <- summary(this_fit)$det)
  
  ests <- bind_rows(
    det_summary   %>% mutate(submodel = "Detection"),
    state_summary %>% mutate(submodel = "Occupancy")
  )
  
  ests$param <- rownames(ests)
  rownames(ests) <- NULL
  ests$param[grepl("Intercept", ests$param)] <- "Intercept"
  
  return(ests)
}

#' @name get_avg_cdp_unmarked
#' @param this_fit A fitted unmarked model, as returned by occu
#' @description This function calculates the average estimated CDP across sites
#'    based on the predictions generated by a fitted unmarked occupancy model.
get_avg_cdp_unmarked <- function(this_fit) {
  y <- this_fit@data@y
  ndet <- rowSums(!is.na(y))
  
  y <- y[ndet > 0,]
  
  if (!is.matrix(y)) return(NA)

  pred_det <- predict(this_fit, "det")
  
  res_by_site <- numeric(nrow(y))
  
  for (i in 1:nrow(y)) {
    start_ind <- 1 + (i - 1) * ncol(y)
    end_ind <- start_ind + ndet[i] - 1
    
    res_by_site[i] <- 1 - prod(1 - pred_det$Predicted[start_ind:end_ind])
  }
  
  return(data.frame(
    mean_cdp = mean(res_by_site),
    nsite_cdp_l90 = sum(res_by_site < .90),
    nsite_wdet_cdp_l90 = sum(res_by_site < 0.9 & rowSums(y, na.rm = T) > 0)
  ))
}

#' @name cluster_occ_ll_forSnapshot
#' @param par A vector of parameters for the clustered occupancy model, of 
#'            length 8. Its elements are, in order: the logit-scale mean 
#'            detection probability; the effect of the first detection covariate;
#'            the effect of the second detection covariate; the logit-scale 
#'            mean occupancy probability; the effect of the first occupancy 
#'            covariate; the effect of the second occupancy covariate; 
#'            logit(theta); and logit(theta').
#' @param dat A named list of covariate and detection data 
#' @param site_has_no_obs A vector of 1s and 0s. If element i=1, it means that 
#'          site i had no observations of the species. Used for faster 
#'          computation.
#' @description This function takes a parameter vector and data and calculates
#'              the log-likelihood of the data given the parameters and the
#'              clustered occupancy model. This is the objective function that 
#'              is optimized when estimating the clustered model for the case \
#'              study. It uses dHMM from nimbleEcology.
cluster_occ_ll_forSnapshot <- function(par, dat, site_has_no_obs) {
  cov_p1 <- dat$cov_p1
  cov_p2 <- dat$cov_p2
  cov_psi1 <- dat$cov_psi1
  cov_psi2 <- dat$cov_psi2
  y <- dat$y_base
  
  logit_p_mu        <- par[1]
  p_beta1           <- par[2]
  p_beta2           <- par[3]
  logit_psi_mu      <- par[4]
  psi_beta1         <- par[5]
  psi_beta2         <- par[6]
  theta             <- expit(par[7])
  theta_prime       <- expit(par[8])
  
  psi  <- expit(logit_psi_mu + 
                  cov_psi1 * psi_beta1 +
                  cov_psi2 * psi_beta2)
  
  p    <- expit(logit_p_mu + cov_p1 * p_beta1 + cov_p2 * p_beta2) 
  
  theta_equil <- theta / (theta + 1 - theta_prime)
  
  ll_per_site <- numeric(nrow(dat$y_alt))
  nobs_vec <- dat$nobs_vec
  
  for (i in 1:nrow(y)) {
    obs_mtx <- matrix(c(1, 0, 1-p[i], p[i]), nrow = 2, byrow = TRUE)
    trans_mtx <- matrix(c(1-theta, theta, 1-theta_prime, theta_prime), nrow = 2, byrow = TRUE)
    
    lprob_obs_given_occu <- dHMM_compiled(y[i, 1:nobs_vec[i]] + 1, 
                                          init = c(1-theta_equil, theta_equil), 
                                          probObs = obs_mtx, 
                                          probTrans = trans_mtx,
                                          len = nobs_vec[i],
                                          checkRowSums = TRUE,
                                          log = TRUE)
    
    if (site_has_no_obs[i]) {
      # Site prob. is the (prob of the data|occupied) * prob occupied, plus prob it is not occupied
      ll_per_site[i] <- log((1-psi[i]) + exp(lprob_obs_given_occu) * psi[i])
    } else {
      # Site prob. is (prob of the data|occupied) * prob occupied
      ll_per_site[i] <- lprob_obs_given_occu + log(psi[i])
    }
  }
  
  return(sum(ll_per_site))
}




#' @name fit_cluster_occ_mod_Snapshot
#' @param dat A named list of covariate and detection data 
#' @param maxit Maximum number of optimization iterations (an optim control
#'              parameter)
#' @description This function estimates the clustered occupancy model for the
#'              snapshot case study. It calls R's optim and the log-likelihood
#'              objective function cluster_occ_ll_forSnapshot.
fit_cluster_occ_mod_Snapshot <- function(dat, maxit = 10000) {
  
  site_has_no_obs <- as.numeric(rowSums(dat$y_base, na.rm=T) == 0)
  
  optimized_soln <- optim(par = rep(0, 8),
                          fn = cluster_occ_ll_forSnapshot, 
                          gr = NULL,
                          dat = dat,
                          site_has_no_obs = site_has_no_obs,
                          control = list(fnscale = -1,
                                         maxit = maxit))
  
  re_optimized_soln <- optim(par = optimized_soln$par,
                             fn = cluster_occ_ll_forSnapshot, gr = NULL,
                             dat = dat,
                             hessian = TRUE,
                             site_has_no_obs = site_has_no_obs,
                             control = list(fnscale = -1,
                                            maxit = maxit),
                             method = "BFGS")

  std_error <- rep(NA, length(re_optimized_soln$par))
  tryCatch({
    std_error <- sqrt(diag(solve(-re_optimized_soln$hess)))
  }, error = function(e) { })
  
  
  return(list(summary = data.frame(
    param = c("logit_p_mu", "p_beta1", "p_beta2",
              "logit_psi_mu", "psi_beta1", "psi_beta2", 
              "logit_theta", "logit_theta_prime"),
    submodel = c(
      "det", "det", "det", "occ", "occ", "occ", NA, NA
    ),
    Estimate = re_optimized_soln$par,
    SE = std_error
  ), 
  convergence = optimized_soln$convergence,
  ll = optimized_soln$value
  ))
}

#' @name fit_hines_to_snapshot
#' @param umf an unmarkedFrameOccu object
#' @description This function is a wrapper around fit_cluster_occ_mod_Snapshot
#'              that also handles converting the unmarkedFrameOccu to a named 
#'              list.
fit_hines_to_snapshot <- function(umf) {
  data_list <- list(
    y_base = umf@y, y_alt = umf@y, 
    nobs_vec = rowSums(!is.na(umf@y)),
    cov_p1 = umf@obsCovs$Canopy_height_scaled[1 + (0:(nrow(umf@y)-1))*ncol(umf@y)],
    cov_p2 = umf@obsCovs$log_roaddist_scaled[1 + (0:(nrow(umf@y)-1))*ncol(umf@y)],
    cov_psi1 = umf@siteCovs$Temp_max_scaled,
    cov_psi2 = umf@siteCovs$Forest_scaled
  )
  
  result <- fit_cluster_occ_mod_Snapshot(dat = data_list)
  result$summary$parname <- c(
    "Intercept", "Canopy_height", "log_roaddist", "Intercept",
    "Temp_max", "Forest", "Theta1", "Theta2"
  )
  
  return(result)
}
